(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{453:function(t,a,s){"use strict";s.r(a);var c=s(2),i=Object(c.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Sequence to Sequence Model是NLP领域非常核心的模型，这类模型使用编码器-解码器的结构，可以实现输入和输出不相同长度序列之间的变换。本篇博客将全面介绍序列到序列模型的基础概念、工作机制，尤其是其中注意力机制的技术更是当前大模型技术的根基之一，最后也会捎带介绍一些序列模型在语音处理的应用。本文也是基于Andrew Ng教授Deep Learning 专项课程中序列模型这门课第三周的内容，那我们开始吧！")]),t._v(" "),a("h2",{attrs:{id:"序列到序列模型的架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#序列到序列模型的架构"}},[t._v("#")]),t._v(" 序列到序列模型的架构")]),t._v(" "),a("p",[t._v("序列到序列模型在近年来成为了众多领域，如机器翻译和语音识别，的核心技术。这种模型能够输入一个序列（如一段文本或音频片段）并输出另一个序列。在机器翻译中，它可以接收一段法文并输出相应的英文翻译。\n以一个英语到法语的翻译任务为例,输入序列 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"x"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"1"}})],1)],1)],1)],1)],1),t._v(" 到 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"x"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"5"}})],1)],1)],1)],1)],1),t._v(" 表示英语句子中的词,输出序列 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"1"}})],1)],1)],1)],1)],1),t._v(" 到 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"6"}})],1)],1)],1)],1)],1),t._v(" 表示对应的法语句子。我们可以训练一个神经网络,输入一段英语句子,输出这段句子的法语翻译。")],1),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692514788230.png",alt:""}})]),t._v(" "),a("p",[t._v("序列到序列模型包含两个重要的组成部分:")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("编码器(Encoder)")]),t._v(":这是一个循环神经网络,比如 LSTM 或 GRU,它读取输入的英语句子,并输出一个固定长度的向量来表示整个输入句子。")]),t._v(" "),a("li",[a("strong",[t._v("解码器(Decoder)")]),t._v(":解码器以编码器输出的向量为初始输入,通过另一个循环神经网络逐个输出翻译后的法语句子中的词语。当生成了句子结束标记时,翻译完成。")])]),t._v(" "),a("p",[t._v("这种结构模仿了人类翻译的过程:先理解原句的意思,然后转换成目标语言进行表达。编码器负责“理解”,解码器负责“表达”。")]),t._v(" "),a("p",[t._v("除此之外，序列到序列模型的思路不仅可以应用于翻译,对"),a("strong",[t._v("图像标注")]),t._v("也很有效。我们可以训练一个模型,输入一张图像,输出这张图像的文字描述。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692514828964.png",alt:""}})]),t._v(" "),a("p",[t._v("具体来说,首先将图像通过卷积神经网络(如预训练的 AlexNet)进行特征提取,去掉网络最后的 softmax 层,得到一个表示图像信息的固定长度特征向量。然后将该向量输入到解码器(循环神经网络)中,生成图像的文本描述。整个模型依然采用编码器-解码器的架构。这样我们就实现了一个图像到文本的转换,也就是自动图像标注。这展示了序列到序列模型的通用性和广泛适用性。需要注意,序列到序列模型和语言模型有本质区别。语言模型估计句子的联合概率 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"P"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"1"}})],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:"22EF"}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-msub",{attrs:{space:"2"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-TeXAtom",{attrs:{size:"s"}},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"T"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1)],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1),t._v(",而序列到序列模型估计条件概率 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"P"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"1"}})],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:"22EF"}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-msub",{attrs:{space:"2"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-TeXAtom",{attrs:{size:"s"}},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"T"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1)],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"|"}})],1),a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"x"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"1"}})],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:"22EF"}})],1),a("mjx-mo",{staticClass:"mjx-n",attrs:{space:"2"}},[a("mjx-c",{attrs:{c:","}})],1),a("mjx-msub",{attrs:{space:"2"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"x"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-TeXAtom",{attrs:{size:"s"}},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"T"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"x"}})],1)],1)],1)],1)],1)],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1),t._v(",即基于特定输入序列,输出特定的翻译或标注序列。这通过编码器来实现条件化。")],1),t._v(" "),a("h2",{attrs:{id:"如何寻找最佳翻译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何寻找最佳翻译"}},[t._v("#")]),t._v(" 如何寻找最佳翻译？")]),t._v(" "),a("p",[t._v("在机器翻译任务中,我们不仅要训练模型生成翻译,还需要从所有可能的翻译中选择最佳结果。")]),t._v(" "),a("h3",{attrs:{id:"条件语言模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件语言模型"}},[t._v("#")]),t._v(" 条件语言模型")]),t._v(" "),a("p",[t._v("机器翻译可以看作是建立一个条件语言模型,也就是给定源语言句子"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"x"}})],1)],1)],1),t._v(",我们要估计目标语言句子"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1),t._v("的条件概率"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"P"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"("}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"y"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:"|"}})],1),a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"x"}})],1),a("mjx-mo",{staticClass:"mjx-n"},[a("mjx-c",{attrs:{c:")"}})],1)],1)],1),t._v("。与语言模型不同,这里的模型是有条件的,输入到解码器的不再是全零向量,而是来自编码器的特征向量,使得模型可以根据输入句子"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"x"}})],1)],1)],1),t._v("生成特定的"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1),t._v("。")],1),t._v(" "),a("p",[t._v("给定一个法语句子,我们可以使用训练好的模型计算不同英语句子的条件概率,然后选择概率最大的那个作为翻译结果。")]),t._v(" "),a("h3",{attrs:{id:"贪心搜索算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪心搜索算法"}},[t._v("#")]),t._v(" 贪心搜索算法")]),t._v(" "),a("p",[t._v("为了找到条件概率最大的翻译"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1),t._v(",一种方法是使用贪心搜索算法。贪婪搜索算法在计算机科学中常常被用来求解最优解，它的主要思想是在每一步都选择当前最好的选项，对生成过程中的每个词，都选择其条件概率最大的那个，然后连接起来。")],1),t._v(" "),a("p",[t._v("具体来说,首先选择最可能的第一个词,然后选择在这个词之后最可能的第二个词,以此类推,直到翻译完成。这种方法很简单,但不一定能找到最优解,因为词与词之间的关系也会影响整句的概率。")]),t._v(" "),a("h3",{attrs:{id:"近似搜索算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#近似搜索算法"}},[t._v("#")]),t._v(" 近似搜索算法")]),t._v(" "),a("p",[t._v("由于待翻译句子的所有可能英语句子数量太大,我们无法穷举地计算每个句子的概率,然后选最大的。因此,需要使用某些近似搜索算法,在可接受的时间复杂度内搜索到足够好的翻译结果。")]),t._v(" "),a("p",[t._v("常用的近似搜索算法包括束搜索、A*搜索等。这些算法不能保证找到最优解,但通常能给出足够好的翻译。我们在后面几章中具体讨论这些算法。")]),t._v(" "),a("h2",{attrs:{id:"束搜索算法-beam-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#束搜索算法-beam-search"}},[t._v("#")]),t._v(" 束搜索算法 （Beam Search）")]),t._v(" "),a("p",[t._v("为了找到机器翻译中最可能的翻译结果,我们可以使用一种叫做束搜索(Beam Search)的算法。\n束搜索算法允许我们在搜索过程中同时保留多种可能性,而不像贪心搜索那样每次只选择一个最优解。具体来说,束搜索使用一个名为"),a("strong",[t._v("束宽")]),t._v("(Beam Width)的超参数,表示在"),a("strong",[t._v("每一步搜索时保留的候选解的数量")]),t._v("。例如束宽为3,意味着我们每次考虑单词序列的前3个最有可能的选择,而不是只考虑概率最高的那个。")]),t._v(" "),a("p",[t._v("让我们以一个英译法的翻译任务为例,看看束搜索算法的执行流程:")]),t._v(" "),a("ol",[a("li",[t._v("对于生成翻译中的第一个词,我们使用解码器模型估计所有可能输出词的概率,然后选择概率最高的B个词作为当前的候选集(B为束宽)。")]),t._v(" "),a("li",[t._v("在第一个词选择出来后,我们基于当前的B个候选集,继续估计第二个词的概率分布。具体是对每个候选句子都估计接下来可能的词的概率。")]),t._v(" "),a("li",[t._v("我们将第一个词和第二个词的联合概率计算出来，并根据这些联合概率重新选择概率最高的B个两词组合，作为下一步的候选集。")]),t._v(" "),a("li",[t._v("如此迭代下去,直到某句译文生成了结束标记。我们就从所有可能的句子中选择联合概率最高的那个，作为最终翻译输出。")])]),t._v(" "),a("p",[t._v("注意，虽然每一步都需要考虑的可能性数量等于词汇量与束宽度的乘积，但我们并不需要实例化这么多的网络复制体，只需根据束宽度实例化相应数量的网络，就可以快速评估所有可能的输出。如果束宽度设置为1，那么束搜索就退化为了贪婪搜索。但通常来说，通过同时考虑多个可能性，束搜索通常能找到比贪婪搜索更好的输出句子。")]),t._v(" "),a("h2",{attrs:{id:"改进束搜索算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改进束搜索算法"}},[t._v("#")]),t._v(" 改进束搜索算法")]),t._v(" "),a("p",[t._v("尽管基本的束搜索算法已经好于贪心搜索,但我们还可以通过一些技巧来进一步提升它的翻译质量。")]),t._v(" "),a("h3",{attrs:{id:"长度归一化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长度归一化"}},[t._v("#")]),t._v(" 长度归一化")]),t._v(" "),a("p",[t._v("在计算句子概率时,我们需要将各个词的概率连乘。这样很容易导致数值下溢,即得出的概率接近零。为了保证数值稳定,一个方法是取对数,将概率换成对数概率,然后进行累加。\n但是这样会导致比例失真——较长的句子由于词的数量多,其概率也会变小，这就会导致算法倾向于选择更短的句子，因为短句子的总概率不会那么小。为平衡这种对长句子的惩罚,我们引入长度归一化,即用句子概率除以句子长度,折算成每个词的平均概率。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692515985923.png",alt:""}})]),t._v(" "),a("p",[t._v("在实践中，我们通常会使用一个软性的方法对概率进行归一化，也就是将句子长度"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-msub",[a("mjx-mi",{staticClass:"mjx-i",attrs:{noIC:"true"}},[a("mjx-c",{attrs:{c:"T"}})],1),a("mjx-script",{staticStyle:{"vertical-align":"-0.15em"}},[a("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[a("mjx-c",{attrs:{c:"y"}})],1)],1)],1)],1)],1),t._v("取 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v(" 次方，然后用这个结果来对概率进行归一化。"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("是一个可以调节的参数，通常设为0.7。如果"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("为1，则完全按照句子长度归一化；如果"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("为0，则不进行归一化。"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("取在0和1之间的值，可以在完全归一化和不归一化之间取一个折中。")],1),t._v(" "),a("p",[t._v("在运行beam search时，我们会看到很多不同长度的句子，假设进行30步，考虑长度为30的句子。那么就会对每种可能的句子长度保留前三个可能性，并用这个得分来打分。然后在所有这些句子中选择一个具有最高归一化对数概率目标值的句子，这就是最后的翻译结果。")]),t._v(" "),a("h3",{attrs:{id:"优化束宽"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化束宽"}},[t._v("#")]),t._v(" 优化束宽")]),t._v(" "),a("p",[a("strong",[t._v("束宽是束搜索的关键超参数")]),t._v("。束宽越大,考虑的可能性也越多,结果越准确但计算成本也高。实际中,根据具体场景选择一个合适的束宽,一般在10到100之间。如果为了得到最好的结果，一些人可能会使用beam宽度为1000或3000，但这也取决于具体的应用和领域。")]),t._v(" "),a("p",[t._v("Beam搜索与完全搜索算法（例如最短路径搜索或深度优先搜索）的区别在于，Beam搜索运行速度更快，但不能保证找到精确的最大值。然而，它在许多实际系统中都有广泛的应用。")]),t._v(" "),a("h2",{attrs:{id:"束搜索错误分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#束搜索错误分析"}},[t._v("#")]),t._v(" 束搜索错误分析")]),t._v(" "),a("p",[t._v("尽管我们在搜索算法上做了改进,翻译结果还是可能存在错误。这时我们需要进行错误分析,判断错误是来自搜索算法还是模型本身,以对症下药。")]),t._v(" "),a("h3",{attrs:{id:"判断错误源头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断错误源头"}},[t._v("#")]),t._v(" 判断错误源头")]),t._v(" "),a("p",[t._v('假设，我们有一个法语句子 "Jane visite l\'Afrique en septembre" 要做英文翻译，人工翻译为 "Jane visits Africa in September"，但机器翻译输出为 "Jane visited Africa last September"，这明显改变了句子的含义。给定一个翻译系统翻译的结果ŷ与人工参考翻译y*,我们可以计算模型给出的两者的概率P(ŷ|x)和P(y*|x),其中x是输入句子。')]),t._v(" "),a("p",[t._v("如果P(y*|x)>P(ŷ|x),那么说明束搜索算法并没有找到概率最高的翻译,问题出在搜索上。这时我们可以通过改进搜索算法来提升性能。反之,如果P(ŷ|x)≥P(y*|x),那么问题就出在模型上,没有学到正确的翻译概率。这时我们就需要通过优化模型本身来提高翻译质量,而不是只关注搜索算法。")]),t._v(" "),a("h3",{attrs:{id:"定量分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定量分析"}},[t._v("#")]),t._v(" 定量分析")]),t._v(" "),a("p",[t._v("通过在数据集上进行上述判断,我们可以定量分析翻译错误源自搜索算法和模型本身的比例。如果大多数错误来自搜索,那么就值得优化搜索算法;如果主要是模型的问题,则应该关注模型改进。这种定量分析可以指导我们有针对性地改进机器翻译系统的性能。同时,这种错误分析思想也适用于任何使用近似搜索算法的复杂系统的性能提升。")]),t._v(" "),a("h2",{attrs:{id:"注意力机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意力机制"}},[t._v("#")]),t._v(" 注意力机制")]),t._v(" "),a("p",[t._v("注意力机制是提升机器翻译系统效果的又一重要方法。它打破了编码器-解码器模型“编码一次,解码多次”的限制,实现更灵活的翻译。目前流行的ChatGPT就是一个运用了注意力机制的编码器-解码器结构的大模型。")]),t._v(" "),a("h3",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("p",[t._v("在基于编码器-解码器的机器翻译模型中，编码器需要将整个输入句子编码成一个固定长度的向量,解码器基于这个向量逐词生成翻译。这种方式在处理长句子时表现不佳，因为输入句子的语义细节很难压缩到一个固定大小的向量中。")]),t._v(" "),a("p",[t._v("注意力机制参考了人类翻译的过程——我们通常不会等读完整个句子才开始翻译，而是边读边翻译，并关注输入句子的不同部分。即注意力机制允许解码器在生成不同的输出词时，"),a("strong",[t._v("关注输入句子的不同部分")]),t._v("，而不需要编码整个句子。")]),t._v(" "),a("p",[t._v("注意力机制为输入句子每个词引入一个权重，这些权重决定了在生成特定的输出词时，应关注输入句子的哪些部分。这通过一个小型神经网络来学习计算。")]),t._v(" "),a("p",[t._v("输入句子的不同词根据权重进行加权求和,得到关注内容的表示,并作为当前解码步骤的条件输入,用于生成输出。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692520540699.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"设计算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计算法"}},[t._v("#")]),t._v(" 设计算法")]),t._v(" "),a("p",[t._v("要实现这个注意力机制模型，我们需要首先假设有一个输入句子，我们用双向RNN、双向GRU或双向LSTM对每个词进行特征计算。网络的前向运行可以得到各个时刻的激活状态，以及反向运行的激活状态。在简化记法中，我们将每个时间步长中由双向RNN的前向和后向运行得出的特征结合表示为 a(t)，其中t代表时间步长。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692520649778.png",alt:""}})]),t._v(" "),a("ul",[a("li",[t._v("在生成翻译时，我们有一个单向RNN，状态为s，它会一次生成一个单词。这个网络接收一个上下文输入C，并根据注意力参数"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("来决定要注意的内容的量。")],1),t._v(" "),a("li",[t._v("我们定义上下文其实就是"),a("strong",[t._v("对不同时间步长特征的加权求和")]),t._v("，权重由注意力参数"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[a("mjx-math",{staticClass:"MJX-TEX"},[a("mjx-mi",{staticClass:"mjx-i"},[a("mjx-c",{attrs:{c:"3B1"}})],1)],1)],1),t._v("决定。这些注意力参数应该是非负的，并且所有参数之和为1。")],1),t._v(" "),a("li",[t._v("生成第一个输出词后，会有一组新的注意力权重，这些权重定义了一个新的加权求和，生成了一个新的上下文，这个上下文也作为输入，使得我们可以生成第二个词。这个过程将不断重复，直到生成完整的翻译。")]),t._v(" "),a("li",[t._v("为了计算这些注意力权重，我们可以使用一个小型神经网络。这个小型神经网络会查看RNN在生成上一次翻译时的隐藏状态，以及每个位置的词的特征。这个小型神经网络会学习这个函数，我们可以使用梯度下降法来训练这个小型神经网络。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692520831045.png",alt:""}})]),t._v(" "),a("p",[t._v("注意力模型的一个缺点是它需要二次方时间来运行。如果输入句子有Tx个词，输出句子有Ty个词，那么注意力参数的总数将是Tx乘以Ty。尽管在机器翻译应用中，输入或输出句子通常都不会很长，因此二次方成本可能是可以接受的。")]),t._v(" "),a("p",[t._v("注意力机制不仅可以应用于文本序列,在计算机视觉中,它也被广泛使用来关注图像的不同区域。注意力机制为编码器-解码器模型提供了更大的表达能力,是该类模型的重要改进之一。它极大地推动了诸如机器翻译、图像字幕生成等任务的进步。")]),t._v(" "),a("h2",{attrs:{id:"应用于语音识别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用于语音识别"}},[t._v("#")]),t._v(" 应用于语音识别")]),t._v(" "),a("p",[t._v("序列到序列模型不仅可以应用于文本翻译,对语音识别也有重要作用。语音识别的目标是将语音音频自动转录成文本。这需要一个模型将时序信号作为输入,输出对应的文本序列。所以语音识别也是一个序列到序列转换的问题,非常适合应用序列到序列模型。")]),t._v(" "),a("p",[t._v("在处理音频数据时，我们常常将原始音频剪辑转化为频谱图，这是一种常见的预处理步骤。频谱图的横轴是时间，纵轴是频率，不同的颜色强度显示了不同频率的能量大小。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692522876124.png",alt:""}})]),t._v(" "),a("p",[t._v("在语音识别的发展历程中，研究者们曾经使用音素来构建语音识别系统。音素是语言学上的基本声音单元，语言学家们尝试使用这些基本单元来转写音频。然而，在端到端深度学习的应用下，研究者发现不再需要这种音素表示法，而是可以直接将音频剪辑输入系统，然后输出相应的文本，而无需使用这些手工设计的音素表示。使用大型数据集对语音识别系统进行训练对此起到了关键作用。最好的商业系统现在训练的数据量已经超过了100,000小时。")]),t._v(" "),a("p",[t._v("在建立语音识别系统时，我们可以采用注意力模型，也可以使用CTC（Connectionist Temporal Classification）损失函数。CTC损失函数可以允许模型生成重复的字符，而这些重复字符之间可以插入特殊的空字符。通过压缩未被空字符分隔的重复字符，我们可以将输出序列长度缩短，这对于输入时间步长比输出更长的情况非常有用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692522982024.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"触发词检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发词检测"}},[t._v("#")]),t._v(" 触发词检测")]),t._v(" "),a("p",[t._v("除了语音转文本外,序列到序列模型在语音领域还有其他应用。那就是触发词检测系统。\n许多语音助手,如Amazon Echo、Apple Siri、小爱同学等都包含触发词检测功能。当检测到指定的触发词时,系统会启动以提供服务。这需要一个模型来实时分析音频流,判断是否出现了触发词。序列模型非常适合解决这个问题。")]),t._v(" "),a("p",[t._v("以循环神经网络（RNN）为例，首先将音频剪辑转换为光谱图特征，再通过RNN传递这些特征。接下来，我们需要定义目标标签。如果音频剪辑中的某个点刚好是用户完成说出触发词的位置，那么在训练集中，可以将该点之前的所有目标标签设置为0，然后在此点之后立即将目标标签设置为1。如果稍后又出现了触发词，那么同样在此后设置目标标签为1。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://leafw-blog-pic.oss-cn-hangzhou.aliyuncs.com/1692523057814.png",alt:""}})]),t._v(" "),a("p",[t._v("这种为RNN设置标签的方法可能会导致训练集失衡，也就是0的数量远多于1。为了解决这个问题，我们可以采取一种“窍门”，即不只在一个时间步骤输出1，而是在一段固定的时间内输出几个1，然后再返回0。这样可以稍微平衡一下1和0的比例。")]),t._v(" "),a("p",[t._v("通过本文的讨论,我们全面了解了序列到序列模型的发展历程，以及它在机器翻译、语音识别和图像描述等重要领域的广泛应用。编码器-解码器框架是该模型的核心,而注意力机制等技术使其可以应对更长的序列处理。我们也看到，大规模的数据集训练对模型效果至关重要。序列到序列模型作为深度学习的典型应用之一,对推动多项人工智能技术发展做出了重大贡献。要想深入学习NLP技术，这些知识都是必不可少的。")]),t._v(" "),a("h2",{attrs:{id:"附录-相关文献"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附录-相关文献"}},[t._v("#")]),t._v(" 附录-相关文献")]),t._v(" "),a("ol",[a("li",[t._v("Mao J, Xu W, Yang Y, et al. Deep captioning with multimodal recurrent neural networks (m-rnn)[J]. arXiv preprint arXiv:1412.6632, 2014.")]),t._v(" "),a("li",[t._v("Vinyals O, Toshev A, Bengio S, et al. Show and tell: A neural image caption generator[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 3156-3164.")]),t._v(" "),a("li",[t._v("Karpathy A, Fei-Fei L. Deep visual-semantic alignments for generating image descriptions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 3128-3137.")]),t._v(" "),a("li",[t._v("Bahdanau D, Cho K, Bengio Y. Neural machine translation by jointly learning to align and translate[J]. arXiv preprint arXiv:1409.0473, 2014.")]),t._v(" "),a("li",[t._v("Graves A, Fernández S, Gomez F, et al. Connectionist temporal classification: labelling unsegmented sequence data with recurrent neural networks[C]//Proceedings of the 23rd international conference on Machine learning. 2006: 369-376.")])])])}),[],!1,null,null,null);a.default=i.exports}}]);